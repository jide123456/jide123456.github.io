<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记得的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-07-21T08:28:41.756Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>jide</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编写文字样式时，行高带来的影响</title>
    <link href="http://yoursite.com/2018/07/21/web-lineheight-and-ps-lineheight/"/>
    <id>http://yoursite.com/2018/07/21/web-lineheight-and-ps-lineheight/</id>
    <published>2018-07-21T06:10:12.000Z</published>
    <updated>2018-07-21T08:28:41.756Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在编写文字样式时，明明是按照设计给的标注写的样式，但文字的间距，却可能会大于设计搞。这一现象，是受文字的行高属性影响导致的。</p><a id="more"></a> <h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>列如，下图1是我随便找的一个标注，下图2是我根据标注写的页面。经手工测量，两行文字的间距为36px，明显超出标注里的11px。</p><img src="/2018/07/21/web-lineheight-and-ps-lineheight/1.jpg" title="标注"><p style="text-align: center"><i>图1</i></p><img src="/2018/07/21/web-lineheight-and-ps-lineheight/2.jpg" title="页面截图"><p style="text-align: center"><i>图2</i></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>造成这一现象的原因是：浏览器不像ps，不是以文字的实际大小计算外边距，而是以文字的盒模型的大小计算外边距。打开浏览器调试工具我们可以发现，文字外边距是从文字盒模型的底部开始计算的。</p><p>由此可以得出，两行文字间的实际距离等于【第一行文字底部到他的盒模型底部的距离】加上【外边距】加上【第二行文字头部到盒模型头部的距离】。所以当我们按照标注给的值设置外边距时，实际外边距会大于设计稿的外边距。 </p><p>文字的盒模型会被文字行高撑开，行高越大，盒模型越大，偏差也就越大。</p><img src="/2018/07/21/web-lineheight-and-ps-lineheight/3.jpg" title="调试工具截图"><p style="text-align: center"><i>图3</i></p><h2 id="怎么解决"><a href="#怎么解决" class="headerlink" title="怎么解决"></a>怎么解决</h2><p>怎么解决？方法有三：</p><h3 id="方法一：将行高设置为1"><a href="#方法一：将行高设置为1" class="headerlink" title="方法一：将行高设置为1"></a>方法一：将行高设置为1</h3><p>将行高设置成1后，文字大小与盒模型大小相等，【第一行文字底部到他的盒模型底部的距离】、【第二行文字头部到盒模型头部的距离】这两个值为0，两行文字间的间距就等于设置的外边距（参考第二段的公式理解）。 <strong>此方法仅适用于单行文字</strong></p><h3 id="方法二：手动计算外边距"><a href="#方法二：手动计算外边距" class="headerlink" title="方法二：手动计算外边距"></a>方法二：手动计算外边距</h3><p>我们知道，文字间的间距由3部分组成，因此我们可以手动计算出外边距值。 例如（假定设计稿中）第一行文字的大小为16px，第二行文字的大小为12px，他们的间距是20px。假定行高为1.5。那么实际设定的外边距值就是：20 - (16 * 1.5 - 16) / 2 - (12 * 1.5 - 12) / 2 = 13(px)。</p><p>ps：文字的盒模型大小 = 文字大小 * 文字行高<br>ps：文字底部到他的盒模型底部的距离 = (文字大小 * 文字行高 - 文字大小) / 2</p><h3 id="方法三：UI标注时连带着行高一起标注"><a href="#方法三：UI标注时连带着行高一起标注" class="headerlink" title="方法三：UI标注时连带着行高一起标注"></a>方法三：UI标注时连带着行高一起标注</h3><p>详见<a href="https://www.jianshu.com/p/55f1d2c9a82e" target="_blank" rel="noopener">这篇文章</a></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本文分析了实际开发中，文字的间距可能与设计稿不一致的现象及原因，并提供了三个解决方案，希望对你有所帮助。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在编写文字样式时，明明是按照设计给的标注写的样式，但文字的间距，却可能会大于设计搞。这一现象，是受文字的行高属性影响导致的。&lt;/p&gt;
    
    </summary>
    
      <category term="css" scheme="http://yoursite.com/categories/css/"/>
    
    
      <category term="解决问题" scheme="http://yoursite.com/tags/%E8%A7%A3%E5%86%B3%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>记一次webpack构建优化</title>
    <link href="http://yoursite.com/2018/04/22/buileOptimize/"/>
    <id>http://yoursite.com/2018/04/22/buileOptimize/</id>
    <published>2018-04-22T02:47:50.000Z</published>
    <updated>2018-06-11T09:47:54.194Z</updated>
    
    <content type="html"><![CDATA[<p>一次偶然的机会，我知道了webpack有很多可视化工具，可以帮助你分析应用的依赖图表，找出不好的地方，让你去优化他们。我通过使用webpack的官方分析工具，优化了项目构建逻辑，使构建后的平均文件的size减少了50kb，部分文件的size减少了100kb。</p><a id="more"></a> <h2 id="webpack-Analyze"><a href="#webpack-Analyze" class="headerlink" title="webpack Analyze"></a>webpack Analyze</h2><p>这是webpack的官方分析工具<a href="https://webpack.github.io/analyse/" target="_blank" rel="noopener">Analyze</a>，使用它之前，你需要先生成一份<strong>包含关于模块的统计数据的json文件</strong>，你可以参照<a href="https://doc.webpack-china.org/api/stats/#src/components/Sidebar/Sidebar.jsx" target="_blank" rel="noopener">这篇文档</a>，如果你使用的是Node APi，那么你可能需要参考<a href="https://doc.webpack-china.org/api/node/#stats-%E5%AF%B9%E8%B1%A1-stats-object-" target="_blank" rel="noopener">这篇文档</a>。</p><p>将生成好的json文件上传至Analyze，你会看到如下图所示界面。这是你应用的构建概览。你可以在Modules，Chunks，Assets目录里看见更详细的报告，也可以在Hints目录里查看优化提示。</p><img src="/2018/04/22/buileOptimize/01.jpg" title="Analyze Home"><h2 id="大量module被多个chunks依赖"><a href="#大量module被多个chunks依赖" class="headerlink" title="大量module被多个chunks依赖"></a>大量module被多个chunks依赖</h2><p>让我们回到主题，点击Hints我发现，在我的应用中有很多个module被多个chunk依赖，这使得我chunk的尺寸比预期要大，会使页面访问速度变慢。我感到很奇怪？我的项目是用Vue-cli生成的，项目里配置了webpack的CommonsChunkPlugin插件，按理说这些被多个chunk依赖的module是会被打包进一个公共文件才对的。为什么这些module没有被打包进公共文件？问题出在哪？</p><img src="/2018/04/22/buileOptimize/02.jpg" title="大量module被多个chunks依赖"><h2 id="问题出在哪呢？"><a href="#问题出在哪呢？" class="headerlink" title="问题出在哪呢？"></a>问题出在哪呢？</h2><p>首先我猜测，可能是CommonsChunkPlugin插件配置不对，我依次尝试了<a href="https://doc.webpack-china.org/plugins/commons-chunk-plugin/" target="_blank" rel="noopener">官方文档</a>上的配置案例，问题任然存在。看来不是配置的问题。那问题出在哪呢？我整个人有点斯巴达，看样子又得去看源码了。</p><p>在看源码之前，我灵光一闪，有了新的发现。</p><p>我在配置代码里加了一行代码，打印资源路径。发现——我通过代码分割功能引入的子chunk的路径并没有出被打印在控制台中，也就是说，<strong>CommonsChunkPlugin不会去提取被分割的子chunk中的公共文件</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">'vendor'</span>,</span><br><span class="line">  minChunks: <span class="function"><span class="keyword">function</span> (<span class="params">module, count</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">module</span>.resource) <span class="comment">// 打印资源路径</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="built_in">module</span>.resource &amp;&amp;</span><br><span class="line">      /\.js$/.test(<span class="built_in">module</span>.resource) &amp;&amp;</span><br><span class="line">      <span class="built_in">module</span>.resource.indexOf(</span><br><span class="line">        path.join(__dirname, <span class="string">'../node_modules'</span>)</span><br><span class="line">      ) === <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;),</span><br></pre></td></tr></table></figure><p>得出的这个令我很兴奋，我马上停用掉代码分割功能，来验证我的想法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过代码分割功能异步引入的页面组件</span></span><br><span class="line"><span class="keyword">const</span> pageOne = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/page/pageOne'</span> <span class="comment">/* webpackChunkName: "pageOne" */</span>)</span><br><span class="line"><span class="keyword">const</span> pageTwo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/page/pageTwo'</span> <span class="comment">/* webpackChunkName: "pageTwo" */</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 停用代码分割功能</span></span><br><span class="line"><span class="keyword">import</span> pageOne <span class="keyword">from</span> <span class="string">'@/page/pageOne'</span></span><br><span class="line"><span class="keyword">import</span> pageTwo <span class="keyword">from</span> <span class="string">'@/page/pageTwo'</span></span><br></pre></td></tr></table></figure><p>验证的结果同我的猜想一样。</p><h2 id="优化结果对比"><a href="#优化结果对比" class="headerlink" title="优化结果对比"></a>优化结果对比</h2><p>找到原因问题就好解决了，既然<strong>CommonsChunkPlugin不会去提取被分割的子chunk中的公共文件</strong>，那我就手动将他们提取到一个公共文件里面去。</p><p>放一张优化前后的构建对比图。</p><img src="/2018/04/22/buileOptimize/03.jpg" title="优化效果对比"><p>从图中可以看到，文件尺寸平均减少了50kb，画红线的三个文件更是减少了100kb。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次偶然的机会，我知道了webpack有很多可视化工具，可以帮助你分析应用的依赖图表，找出不好的地方，让你去优化他们。我通过使用webpack的官方分析工具，优化了项目构建逻辑，使构建后的平均文件的size减少了50kb，部分文件的size减少了100kb。&lt;/p&gt;
    
    </summary>
    
      <category term="js" scheme="http://yoursite.com/categories/js/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="优化" scheme="http://yoursite.com/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Hello Hexo</title>
    <link href="http://yoursite.com/2018/04/15/helloWorld/"/>
    <id>http://yoursite.com/2018/04/15/helloWorld/</id>
    <published>2018-04-15T07:52:08.000Z</published>
    <updated>2018-04-25T13:53:40.256Z</updated>
    
    <content type="html"><![CDATA[<p>去年买的搬瓦工的服务器，因为到期了太久没有续费，已经被厂商关闭了，部署在上面的博客自然也访问不到了。也没有心思把它再重新搭建起来，天知道我当初搭建它时查了多少文章。[笑哭]</p><p>但话又说回来了，博客是coder的脸面，没有的话又有点说不过去，只好另辟蹊径，找到了Hexo。</p><a id="more"></a> <h2 id="说说Hexo"><a href="#说说Hexo" class="headerlink" title="说说Hexo"></a>说说Hexo</h2><p>Hexo的使用体验是简单 + 愉快的，基本上跟着<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">官方教程</a>敲一遍就能上手，书写方面采用的是MarkDown，学起来也很快。部署方面也很简单，将写好的文章传到服务器上就可以了（就你废话多）。这里我还参考了<a href="https://zhuanlan.zhihu.com/p/26625249" target="_blank" rel="noopener">知乎的一篇文章</a>。</p><p>从想法萌生到新博客诞生，整个过程算下来不到2个小时，还是挺快的。让人心情预愉悦^ ^</p><p>今天就先到这了~</p><p>以上。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;去年买的搬瓦工的服务器，因为到期了太久没有续费，已经被厂商关闭了，部署在上面的博客自然也访问不到了。也没有心思把它再重新搭建起来，天知道我当初搭建它时查了多少文章。[笑哭]&lt;/p&gt;
&lt;p&gt;但话又说回来了，博客是coder的脸面，没有的话又有点说不过去，只好另辟蹊径，找到了Hexo。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
</feed>
